#!/usr/bin/python3

import os
import sys
import json
import struct
import signal
import argparse
from zoneinfo import ZoneInfo
from datetime import datetime as dt

class TalonWAVFile:
    def __init__(self, filename, section=None, taxonomy=None, clear=False, debug=False):
        self.metadata = {}
        self._filename = filename
        self._section = section
        self.metadata['section'] = {}
        self.metadata['name'] = os.path.basename(self._filename)
        self.metadata['events'] = []

        self._taxonomy = taxonomy

        self._guano = None
        self._debug = debug

        if self._section:
            self._curtz = ZoneInfo(self._section['timezone'])
            self._timestamp = dt.strptime(str(os.path.basename(self._filename)), self._section['file_format'])
            self._timestamp.astimezone(self._curtz)

            for key in section:
                self.metadata['section'][key] = section[key]

        if os.path.exists(self._filename):
            self.metadata['st_mtime'] = dt.fromtimestamp(os.stat(self._filename).st_mtime)
            self._parse_chunks()

    def _get_chunk(self, fp):
        chunk = []
        chunk_offset = fp.tell()
        data = fp.read(8)

        if len(data) == 8:
            chunk_id = data[0:4].decode()
            chunk_sz = chunk_sz_orig = int.from_bytes(data[4:8], byteorder='little')

            # adjust chunk size if chunk size is odd, as there should be a padding byte
            if chunk_sz % 2 > 0:
                chunk_sz += chunk_sz % 2

            chunk = [ chunk_id, chunk_sz, chunk_offset, chunk_sz_orig % 2 ]

        return chunk

    def _json_serializer(self, obj):
        # keep datetimes natively in the dict, but auto convert them
        # to iso formatted datetimes for printing or json dumping
        if isinstance(obj, (dt)):
            return obj.isoformat()

        # any byte strings we get from the various chunks will be non-
        # printable, so convert them to hex in a format similar to xxd
        if isinstance(obj, (bytes)):
            return obj.hex(' ', 2)

        raise TypeError ("Type %s not serializable" % type(obj))

    def _parse_chunks(self):
        try:
            with open(self._filename, 'rb') as f:
                # this is the order in which chunks were found, so we can 
                # reconstruct the file in the correct order
                order = 0
                self.metadata['st_size'] = 0
                self.metadata['duration'] = 0
                self.metadata['chunks'] = {}
                riff_id, riff_sz, chunk_offset, padding = self._get_chunk(f)

                if riff_id == 'RIFF':
                    riff = {}
                    riff['name'] = riff_id
                    riff['size'] = riff_sz
                    riff['offset'] = 0
                    riff['wavid'] = f.read(4).decode()
                    riff['order'] = order

                    self.metadata['chunks']['riff'] = riff
                    # self.metadata['type'] = 'RIFF'
                    # self.metadata['format'] = 'WAVE'
                    self.metadata['st_size'] = os.stat(self._filename).st_size

                    if riff['wavid'] == 'WAVE':
                        while True:
                            order += 1
                            offset = f.tell()

                            if offset >= self.metadata['st_size']:
                                break

                            chunk_id, chunk_sz, chunk_offset, padding = self._get_chunk(f)

                            if chunk_id:
                                chunk = {}

                                chunk['name'] = chunk_id
                                chunk['offset'] = chunk_offset
                                chunk['size'] = chunk_sz
                                chunk['padding'] = padding
                                chunk['order'] = order

                                if chunk_id == 'fmt ':
                                    data = f.read(chunk_sz)

                                    # format 1 is PCM, format 3 is IEEE Float
                                    chunk['format'] = int.from_bytes(data[0:2], byteorder='little')
                                    chunk['channels'] = int.from_bytes(data[2:4], byteorder='little')
                                    chunk['samples_sec'] = int.from_bytes(data[4:8], byteorder='little')
                                    chunk['bytes_sec'] = int.from_bytes(data[8:12], byteorder='little')
                                    chunk['block_size'] = int.from_bytes(data[12:14], byteorder='little')
                                    chunk['bit_depth'] = int.from_bytes(data[14:16], byteorder='little')

                                    ext_size = int.from_bytes(data[16:18], byteorder='little')
                                    chunk['ext_size'] = ext_size
                                    chunk['ext_data'] = data[18:18+ext_size] #.hex(' ', 2)
                                elif chunk_id == 'guan':
                                    data = f.read(chunk_sz)

                                    chunk['data'] = TalonWAVFile.decode_guano(data)
                                    chunk['offset'] = chunk_offset
                                    chunk['size'] = chunk_sz
                                elif chunk_id == 'data':
                                    # don't need to read the entire data chunk into memory as it may be very large, 
                                    # just record the size and skip to the next chunk
                                    f.seek(chunk_sz, 1)
                                else:
                                    chunk['data'] = f.read(chunk_sz)

                                self.metadata['chunks'][chunk['name'].strip()] = chunk
                            else:
                                break
                else:
                    print('Not a WAV file.')
        except FileNotFoundError:
            print(f"Error: File '{self._filename}' not found.")
        except Exception as e:
            print(f"An error occurred: {e}")

    @property
    def channels(self):
        return self.metadata['chunks']['fmt']['channels']

    @property
    def rate(self):
        return self.metadata['chunks']['fmt']['rate']

    @property
    def bits(self):
        return self.metadata['chunks']['fmt']['bit_depth']

    @property
    def duration(self):
        return self.metadata['chunks']['data']['size'] / self.metadata['chunks']['fmt']['bytes_sec']

    def ExtractChannel(self, channel=0, quiet=False):
        self._extract_channel(channel, quiet)

    def _extract_channel(self, channel=0, quiet=False):
        dest_path, filename = os.path.split(self._filename)
        filename, extension = os.path.splitext(filename)
        outfile = os.path.join(dest_path, str(filename) + f"-{channel}" + f"{extension}")

        if not os.path.exists(outfile):
            with open(outfile, 'wb') as o:
                # python >= 3.7 maintains insertion order for dicts, so we can
                # rely on ['chunks'] being in the proper order as we loop through
                for cur in self.metadata['chunks']:
                    chunk = self.metadata['chunks'][cur]

                    # reinitialize header var for each chunk
                    header = b''

                    if chunk['name'] == 'RIFF':
                        header += struct.pack('4s', chunk['name'].encode())
                        header += struct.pack('<l', chunk['size'])
                        header += struct.pack('4s', chunk['wavid'].encode())

                        o.write(header)
                    elif chunk['name'] == 'fmt ':
                        # TODO: calculate sized based on the data we're packing
                        header += struct.pack('4s', chunk['name'].encode())
                        header += struct.pack('<l', chunk['size'])         # 4
                        header += struct.pack('<H', chunk['format'])       # 2
                        header += struct.pack('<H', 1)                     # 2
                        header += struct.pack('<l', chunk['samples_sec'])  # 4
                        header += struct.pack('<l', int(chunk['bytes_sec']/chunk['channels']))    # 4
                        header += struct.pack('<H', int(chunk['block_size']/chunk['channels']))   # 2
                        header += struct.pack('<H', chunk['bit_depth'])    # 2

                        if chunk['ext_size'] > 0:
                            header += struct.pack('<H', chunk['ext_size'])     # 2
                            header += struct.pack(f"{len(chunk['ext_data'])}s", chunk['ext_data'])

                        bpb = chunk['block_size']
                        bpc = int(chunk['bit_depth'] / 8)

                        o.write(header)
                    elif chunk['name'] == 'data':
                        # write data chunk name
                        o.write(struct.pack('4s', chunk['name'].encode()))

                        # write size of 0 for now, we'll update it later
                        oldpos = o.tell()
                        o.write(struct.pack('<l', 65536))

                        # BLOCK_SIZE should be evenly divisible by bpb or bpc so that
                        # when we grab the next chunk we're not starting in the middle
                        # of block of channels
                        BLOCK_SIZE = 65536 * bpb * 4

                        # bytes per block
                        bpb = self.metadata['chunks']['fmt']['block_size']

                        # bytes per channel
                        bpc = int(self.metadata['chunks']['fmt']['bit_depth'] / 8)
                        out_chunk = bytearray()

                        with open(self._filename, 'rb') as f:
                            # offset is the beginning of the data block, the data portion
                            # follows the 4-byte name and 4-byte size
                            f.seek(self.metadata['chunks']['data']['offset'] + 8)

                            remaining = chunk['size']
                            complete = 0

                            while True:
                                if not quiet:
                                    print(f"Splitting channel {channel} from {self._filename}: {(complete / chunk['size'])*100:3.2f}%", end='\r', flush=True)

                                if not remaining > 0:
                                    break

                                if BLOCK_SIZE > remaining:
                                    BLOCK_SIZE = remaining

                                in_chunk = f.read(BLOCK_SIZE)
                                i = channel * bpc

                                while i < BLOCK_SIZE:
                                    out_chunk += (in_chunk[i:i+bpc])
                                    i += bpb

                                o.write(out_chunk)
                                out_chunk.clear()

                                remaining -= BLOCK_SIZE
                                complete += BLOCK_SIZE

                        if not quiet:
                            print()
                        
                        # record current position
                        curpos = o.tell()

                        # diff between old and cur is data size (-4 because oldpos is before the 4 byte size)
                        data_size = curpos - oldpos - 4

                        # rewind to old pos and write data size
                        o.seek(oldpos)
                        o.write(struct.pack('<l', data_size))

                        # go back to curpos so we can write any
                        # remaining chunks in the file
                        o.seek(curpos)
                    elif chunk['name'] == 'guan':
                        header += struct.pack('4s', chunk['name'].encode())
                        data = TalonWAVFile.encode_guano(chunk['data'])
                        size = len(data)
                        header += struct.pack('<l', size)
                        header += struct.pack(f"{len(data)}s", data)

                        o.write(header)
                    else:
                        header += struct.pack('4s', chunk['name'].encode())
                        header += struct.pack('<l', chunk['size'])
                        header += struct.pack(f"{len(chunk['data'])}s", chunk['data'])

                        o.write(header)
                
                # RIFF size is total size of the file minus the 4-by chunk name (RIFF)
                # and the 4 byte size.
                riff_size = o.seek(0, 2) - 8

                o.seek(4)
                o.write(struct.pack('<l', riff_size))
        else:
            print(f"Destination file exists, please remove and try again: {outfile}")

    def __str__(self):
        return json.dumps(self.metadata, indent=4, sort_keys=False, default=self._json_serializer)

    def to_dict(self):
        return {
            "File name": self.file_name
        }

    @staticmethod
    def encode_guano(data):
        output = ""

        for key in data:
            if not isinstance(data[key], dict):
                output += f"{key}: {data[key]}\n"
            else:
                for k in data[key]:
                    output += f"{key}|{k}: {data[key][k]}\n"

        return output.encode()

    @staticmethod
    def decode_guano(data):
        tmp = {}

        # we can read the guano data ourselves now
        for item in data.decode().split('\n'):
            if len(item) > 0:
                key, val = item.split(': ')

                # parse namespaces as dicts
                if '|' in key:
                    key, subkey = key.split('|')

                    if key not in tmp:
                        tmp[key] = {}
                    
                    tmp[key][subkey] = val
                else:
                    tmp[key] = val

        return tmp

def signal_handler(signum, frame):
    signal.signal(signum, signal.SIG_IGN)
    sys.exit(0)

def ParseCommandLineArguments():
    arg_parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description="tsplit is a utility for extracting one channel from a WAV file.")
    arg_parser.add_argument('-i', '--input', type=str, required=True, help="Path to the wave file to split.")
    arg_parser.add_argument('-c', '--channel', type=int, default=0, help="In stereo files, left is 0, right is 1.")
    arg_parser.add_argument('-d', '--debug', action='store_true', help='Print extra debugging information.')
    arg_parser.add_argument('-q', '--quiet', action='store_true', help="Don't display progress indicator.")
    arg_parser.add_argument('-m', '--metadata', action='store_true', help="Don't split, just display WAV metadata is JSON format.")

    return arg_parser

def main():
    arg_parser = ParseCommandLineArguments()
    args = arg_parser.parse_args()

    signal.signal(signal.SIGINT, signal_handler)

    if os.path.exists(args.input):
        twf = TalonWAVFile(args.input)

        if args.metadata or args.debug:
            print(twf)
        else:
            if args.channel <= twf.metadata['chunks']['fmt']['channels']-1:
                twf.ExtractChannel(channel=args.channel, quiet=args.quiet)
            else:
                print(f"Specified channel exceeds number of channels in WAV file.")
    else:
        print(f"Input file does not exist.")


if __name__ == "__main__":
    main()
